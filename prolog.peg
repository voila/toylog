/*
 
rules = 
[
    [a('append',[c('nil'),v('X'),v('X')])],

    [a('append',[a('cons', [v('H'),v('X')]), 
                 v('Y'), 
                 a('cons', [v('H'),v('Z')])]),
       a('append',[v('X'), v('Y'), v('Z')])]
]

goal = 
a('append',[
    a('cons',[c('1'), a('cons',[c('2'), c('nil')])]),
    a('cons',[c('3'), a('cons',[c('4'), c('nil')])]),
    v('Z')
])

 */

start
  = space* p:prog space* { return p; }
    

space
  = [ \t\r\n]
  / comment

ispace = [ \t] / comment

newline
  = [r\n]

comment
  = "%" [^\r\n]*

prog = ps:clause+ { return {clauses: ps}; }

/*
goal = ":-" ispace* g:terms ispace* "."
*/

clause 
  = fact:atom "." space+ {return [fact]; }
  / head:atom space* ":-" space* body:terms "." space+ {return [head].concat(body); }



term = space* v:var space* { return v }
  / space* a:atom space* { return a }
  / space* c:constant space* { return c }

list =
   "[" space* "]" {return {type: 'const', id:'nil'}}

 / "[" x:elem "|" l:listv "]" 
    {return {type: 'atom', id:'cons', params: [x, l]}}

 / "[" xs:elems "]" {return xs}


listv = list / var

elems = 
   x:elem "," xs:elems { return {type: 'atom', id:'cons', params: [x, xs]} }
  / x:elem { return {type: 'atom', id:'cons', params: [x, {type: 'const', id:'nil'}]}}

elem =
   space* t:term space* {return t}
     


var = 
  '_' {return {type: 'var', id:'_'}}
  / c:[A-Z] cs:[a-z0-9]* { return {type: 'var', id:c + cs.join('')}; }

constant = 
   n:number { return {type: 'const', id:n}; }
 / cs:symbol
   { return {type: 'const', id:cs}; }


number
  = l:[0-9]* '.' r:[0-9]+  
    { return parseFloat(l.join('') + '.' + r.join('')); }
  / n:[0-9]+ 
    {return parseInt(n.join('')); }

symbol = 
  c:[a-z] cs:[a-z0-9_]* 
  { return c + cs.join(''); }

atom = 
  cs:symbol "(" ps:terms ")"
  { return {type:'atom', id: cs, params:ps}; }
 / list

terms = 
  t:term "," ts:terms { return [t].concat(ts);}
  / t:term { return [t];}


/*
terms = 
  t1:term "," t2:term "," t3:term { return [t1,t2, t3];}
  / t1:term "," t2:term { return [t1,t2];} 
  / t:term { return [t];}
*/